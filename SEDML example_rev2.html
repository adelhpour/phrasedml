<!doctype html>
<header>
	<h1>New Suggestions for Simulation Setup Language</h1>
	<h3>Revision 2</h3>
</header>
<body>
<h2>General SED-ML Structure</h2>
<p>SED-ML files are generally structured into 5 distinct parts which include model, simulation, task, data generator, and output.<br><br></p>
<h2>Structure of the New Language</h2>
<p>Similar to antimony, the SED-ML counterpart will be presented as a text string, starting with a specific keyword.</p>
<code><pre>SEDMLstr = '''
*StartSedmlFormulation
...
...
...
end
'''</pre></code>
<p>This allows the setup string to be separated from or integrated to the antimony string.<br><br></p>
<h3>Models</h3>
<p>Load models in with appropriate changes to be made prior to simulation.<br>
<blockquote><code>model_id = <i>model</i> sources <i>with</i> changes</code></blockquote><br>
<code>Sources</code>: Sources can be either variable pointing to antimony string or text string pointing to local/online model path<br>
<blockquote><code>model_load = model "C:\\The_path_to_the_model"</code></blockquote><br>
<code>Changes</code>: Supports attribute changes, XML changes(add, change, remove), and compute changes<br>
<blockquote>Attribute change: Changes the XML attribute value with provided value<br>
<code>attribchange = <i>model</i> source <i>with</i> S1 = 0.5, S2 = 1.5, ...</code></blockquote>
<blockquote>Add XML: Add new XML element as a child element of specified target<br>
<code>addXML = <i>model</i> source <i>with</i> <u>add</u> parameter V_mT = 0.7</code></blockquote>
<blockquote>Change XML: Replace XML elements<br>
<code>changeXML = <i>model</i> source <i>with</i> <u>change</u> V_mT <u>to</u> V_mT_1 = 0.5, V_mT_2 = 0.3</code></blockquote>
<blockquote>Remove XML: Delete specified XML elements or attributes<br>
<code>removexml = <i>model</i> source <i>with</i> <u>remove</u> J1, J2</code></blockquote>
<blockquote>Compute change XML: Allows to compute change for numerical values of elements or attribute<br>
<code>compute = <i>model</i> source <i>with</i> <u>compute</u> R1 = k1/k2</code></blockquote><br></p>
<h3>Simulations</h3>
<p>Supporting uniform time course, onestep, and steady state simulation, which will be distinguished based on the type of arg.<br>
<blockquote><code>sim_id = <i>simulate</i> simulation_type</code></blockquote><br>
<code>Simulation_type</code>: supports uniform time course, one step, and steady state simulation<br><br>
<code>uniform(<i>start</i>, <i>end</i>, <i>numberOfPoints</i>)</code><br>
<BLOCKQUOTE>Uniform time course simulation using specified initial time, final time, and number of points between them. Analogous to numpy.linspace.<br>
<code>sim_uniform = simulate uniform(0, 10, 100)</code></BLOCKQUOTE>
<code>onestep(<i>stepsize</i>)</code><br>
<BLOCKQUOTE>Simulation of the next step with specified step size based on the current state<br>
<code>sim_one_step = simulate onestep(0.5)</code></BLOCKQUOTE>
<code>steadystate</code><br>
<blockquote>Steady state simulation<br>
<code>sim_steady = simulate steadystate</code></blockquote><br></p>
<h3>Tasks</h3>
<p>Links models to simulations. <br>
<blockquote><code>task_id = <i>run</i> model_id <i>with</i> simulation_id</code></blockquote><br></p>
<h3>Repeated Tasks</h3>
<p>Repeated task allows multiple simulations to be done by specifying loop.<br>
<blockquote><code>repeatedtask_id = <i>repeat</i> task_id <i>for</i> target_id <i>in</i> repeat_type (<i>with</i> reset)</code></blockquote><br>
<code>Task_id</code>: Task to be repeated<br><br>
<code>Target_id</code>(optional): Element/attribute to be iterated according to designated repeat_type. This is an optional variable.<br><br>
<code>Repeat_type</code>: Designate the sequence to iterate.<br><br>
<code>uniform(<i>start</i>, <i>end</i>, <i>numberOfPoints</i>, <i>typeOfRange</i> = ("linear"|"log"))</code><br>
<blockquote>Set uniform range with linearly(or logarithmically) spaced points with provided initial, final, and number of points. Argument typeOfRange will accept either "linear" or "log" which will space the numbers linearly or logarithmically. The default value is "linear". Analogous to numpy.linspace(or numpy.logspace).<br>
<code>repeat_uniform = repeat task1 for J4_KK5 in uniform(1, 40, 100)</code></blockquote>
<code>vector(<i>array</i>)</code><br>
<blockquote>Set an array of numbers to be iterated.<br>
<code>repeat_vector = repeat task1 for J1_KK2 in vector([1,2,3])</code></blockquote><br>
<code>function(<i>function</i>)</code><br>
<blockquote>Set a function that returns an array of numbers to be iterated.<br>
<code>repeat_fuction = repeat task1 for S1 in function(uniform(1, 40, 100)*S1)</code></blockquote><br>
<code>Reset</code>: Resets model to the initial state after each iteration. The default is False unless <code>with reset</code> argument is supplied.<br><br>
Multiple repeated tasks can be fully described by defining several repeated task components that points to each other.<br>
<code><blockquote><pre>task0 = run model_1 with simulation_1;
repeatedtask_1 = repeat task0 for J0 in uniform(0,10,10);
repeatedtask_2 = repeat repeatedtask_1 for J1 in vector([1,3,5,7,11,13]);
</pre></blockquote></code>
The above code block demonstrates using the specified notation to perform parameter scan.<br>
Unspecifying the target_id designates that repeated task as a simple for-loop for i.e. stochastic simulation.<br><br></p>
<h3>Outputs</h3>
<p>Plotting will start with <i>plot</i> notation followed by a x variable <i>vs</i> y variables. Each variable will be preceded by the task it is running on, separated with a dot. Functions involving defined elements/attributes for x and y variables are supported. Instead of predefining task_id, direct input of <i>simulate</i> argument will work only if there is only a single model and the user does not intend on specifying the task.<br>
<blockquote><code><i>plot</i> task.x <i>vs</i> task.y1, task.y2, task.y3, ...</code></blockquote></p>
<p>Example:<br><code>plot task1.time vs task1.S1, task1.S2<br>
plot task0.time vs task0.S1/compartment1, task0.S2/compartment1<br>
plot time vs S1 simulate steadystate</code><br><br></p>
<h2>Examples</h2>
<h3>Uniform time course simulation using antimony</h3>
<code><pre>Model_00001_sbml_l3v1 = '''
//Created by libAntimony v2.6.0
model *case00001()
  // Compartments and Species:
  compartment compartment_;
  species S1 in compartment_, S2 in compartment_;

  // Reactions:
  reaction1: S1 => S2; compartment_*k1*S1;

  // Species initializations:
  S1 = 0.00015/compartment_;
  S1 has substance_per_volume;
  S2 = 0;
  S2 has substance_per_volume;

  // Compartment initializations:
  compartment_ = 1;
  compartment_ has volume;

  // Variable initializations:
  k1 = 1;

  // Other declarations:
  const compartment_, k1;

  // Unit definitions:
  unit volume = litre;
  unit substance = mole;
  unit time_unit = time_unit;
  unit substance_per_volume = mole / litre;
end
'''

SedmlStr = '''
*StartSedmlFormulation
  // list of models
  model_1 = model Model_00001_sbml_l3v1;
  
  // type of simulations
  sim_1 = simulate uniform(0, 5, 51);
  
  // list of tasks
  task_1 = run model_1 with sim_1;
  
  // plotting
  plot task_1.time vs task_1.S1/compartment_, task_1.S2/compartment_;
  
  // A simplified method of plotting
  plot time vs S1/compartment_, S2/compartment_ simulate uniform(0, 5, 51));
end
'''

import tellurium as te

te.execute(Model_00001_sbml_l3v1, SedmlStr)</pre></code><br></p>
<h3>Le Loup Model</h3>
<code><pre>SedmlStr = '''
*StartSedmlFormulation
  model1 = model "urn:miriam:biomodels.db:BIOMD0000000021";
  model2 = model model1 with V_mT = 0.28, V_dT = 4.8;
  simulation1 = simulate uniform(0, 380, 1000);
  task1 = run model1 with simulation1;
  task2 = run model2 with simulation1;
  plot task1.time vs task1.Mt;
  plot task2.time vs task2.Mt;
  plot task1.Cn vs task1.Mt;
  plot task2.Cn vs task2.Mt;
end
'''</pre></code><br>
<h3>The IkappaB-NF-kappaB signaling module</h3>
<code><pre>SedmlStr = '''
*StartSedmlFormulation
  model1 = model "urn:miriam:biomodels.db:BIOMD0000000140";
  simulation1 = simulate uniform(0, 2500, 1000);
  task1 = run model1 with simulation1;
  plot task1.time vs task1.Total_NFkBn, task1.Total_IkBbeta, task1.Total_IkBeps, task1.Total_IkBalpha;
end
'''</pre></code><br>
<h3>Perturbation</h3>
<code><pre>SedmlStr = '''
*StartSedmlFormulation
  model1 = model "http://sourceforge.net/p/libsedml/code/119/tree/trunk/Samples/models/oscli.xml?format=raw";
  stepper = simulate onestep(0.1);
  task0 = run model1 with stepper;
  task1 = repeat task0 for J0_v0 in function(piecewise(x = uniform(0, 10, 100), [x<4, 4<=x<6, x>=6], [8, 0.1, 8]));
  plot task1.time vs task1.S1, task1.S2, task1.J0_v0;
end
'''</pre></code><br>
<h3>Repeated stochastic simulation</h3>
<code><pre>SedmlStr = '''
*StartSedmlFormulation
  model1 = model "C:\borisejb.xml";
  timecourse1 = simulate uniform(0, 4000, 1000);
  task0 = run model1 with timecourse1;
  task1 = repeat task0 for uniform(0, 10, 10) with reset;
  plot task1.time vs task1.MAPK, task1.MAPK_P, task1.MAPK_PP, task1.MKK, task1.MKK_P, task1.MKKK, task1.MKKK_P;
end
'''</pre></code><br>
<h3>1D time course parameter scan</h3>
<code><pre>SedmlStr = '''
*StartSedmlFormulation
  model1 = model "http://sourceforge.net/p/libsedml/code/119/tree/trunk/Samples/models/oscli.xml?format=raw";
  timecourse1 = simulate uniform(0, 20, 1000);
  task0 = run model1 with timecourse1;
  task1 = repeat task0 for J0_v0 in vector([8, 4, 0.4]) with reset;
  plot task1.time vs task1.S1, task1.S2;
end
'''</pre></code><br>
<h3>2D steady state parameter scan</h3>
<code><pre>SedmlStr = '''
*StartSedmlFormulation
  model_3 = model Borisejb;
  sim_repeat = simulate steadystate;
  task_1 = run model_3 with sim_repeat;
  repeatedtask_1 = repeat task_1 for J1_KK2 in vector([1, 5, 10, 50, 60, 70, 80, 90, 100]);
  repeatedtask_2 = repeat repeatedtask_1 for J4_KK5 in uniform(1, 40, 100);
  plot repeatedtask_2.J4_KK1 vs repeatedtask_2.MKK_1, repeatedtask_2.MKK_P_1;
end
'''</pre></code>
</body>
